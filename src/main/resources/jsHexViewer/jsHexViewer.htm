<html>
<head>
<style>
	body {
		font-family: Verdana;
		margin: 0px;
		background-color: rgb(51, 51, 51);
		font-size: 11px;
	}

	.byteWrapper, .linenr, .spacer {
		display: table-cell;
	}

	.byteWrapper, .spacer, .spacerRow {
		cursor: text;
	}

	.byteWrapper {
		min-width: 14px;
		text-align: center;
	}

	.linenr {
		padding-right: 4px;
		margin-right: 10px;
		text-align: right;
		background-color: #292929;
		color: #75abff;
	}

	.selected {
		background-color: #2929d0;
		color: white;
	}

	.row {
		font-size: 16px;
	}

	.name {
		font-size: 16px;
		font-weight: bold;
	}

	.row {
		display: table-row;
	}

	.spacerRow {
		height: 3px;
	}

	#hexview, #asciiview {
		display: table;
		color: white;
	}

	#hexview {
		float: left;
		padding-right: 10px;
		border-right: 2px solid grey;
	}

	#asciiview {
		padding-left: 10px;
	}

	#values {
		font-size: 12px;
	}

	#pagesOfInterest button {
		display: inline-block;
		width: 100px;
	}

	#left-component {
		right: 300px;
		margin-right: 5px;
	}

	#my-divider {
		right: 300px;
		width: 5px;
		background-color: grey;
	}

	#right-component {
		width: 300px;
	}

	.hexviewWrapper {
		display: flex;
		justify-content: center;
		align-items: center;
		height: 100%;
	}
	
	fieldset {
		margin-bottom: 4px;
	}

	.split-pane {
		position: relative;
		height: 100%;
		width: 100%;
		overflow: hidden;
		z-index: 0;
	}
	
	.split-pane.fixed-right > .split-pane-component {
		position: absolute;
		top: 0;
		height: 100%;
		overflow: auto;
		left: auto;
		right: 0;
		z-index: 1;
	}
	
	.split-pane.fixed-right > .split-pane-component:first-child {
		left: 0;
		right: auto;
	}
	
	.split-pane.fixed-right > .split-pane-divider {
		position: absolute;
		height: 100%;
		top: 0;
		cursor: col-resize;
		z-index: 2;
	}
	
	.split-pane.fixed-right > .split-pane-divider > .split-pane-divider-inner {
		position: absolute;
		top: 0;
		left: -5px;
		box-sizing: content-box;
		width: 100%;
		height: 100%;
		padding: 0 5px;
	}
	
	.split-pane-resize-shim {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 10000;
		display: none;
	}

	.split-pane.fixed-right > .split-pane-resize-shim {
		cursor: col-resize;
	}
</style>
<link rel="stylesheet" href="libs/jquery-ui-1.12.1/jquery-ui.min.css">
<script src="https://code.jquery.com/jquery-1.11.3.js"></script>
<script src="libs/jquery-ui-1.12.1/jquery-ui.min.js"></script>
<script src="https://raw.githubusercontent.com/shagstrom/split-pane/master/split-pane.js"></script>
<script>
var hover = true;
var page = 0;
var pageSize = 1024;
var columnCount = 0; <!-- generated -->

function unpack(buffer, asBigEndian) {
	if (buffer.length == 1 || buffer.length == 2 || buffer.length == 4 || buffer.length == 6 || buffer.length == 8) {
		 var value = 0;
		 for (var j = 0, i = asBigEndian ? buffer.length - 1 : 0; asBigEndian ? i >= 0 : i < buffer.length; asBigEndian ? i-- : i++, j++) {
			 value |= (buffer[i] & 0xff) << (j * 8);
		 }
		 return value;
	}
	return '';
}

$(function() {
	$('div.split-pane').splitPane();
	$('#accordion').accordion({
		heightStyle: 'fill'
	});

	$('body').on('mouseenter', '.byte', function() {
		if (!hover) {
			return;
		}

		clearSelection();
		var position = parseInt($(this).attr('position'));
		$('.byte[position=' + position +']').each(function(index, value) {
			$(value).addClass('selected');
		});

		$('#filePosition').text(position);
		$('#filePositionhex').text(toHex(position));

		var definition = getDefinition(parseInt(position)); // TODO int != long
		if (definition) {
			var name = definition[2];
			$('.name').text(name.lastIndexOf('.') === -1 ? name : name.substring(name.lastIndexOf('.') + 1));
			$('.fullname').text(name);

			getData(definition[0], definition[1], function(buffer) {
				$('#values #length').text(buffer.length);
				if (buffer.length <= 8) {
					var be = unpack(buffer, true);
					var le = unpack(buffer, false);
					$('#values #be').text(be);
					$('#values #behex').text(be.toString(16));
					$('#values #le').text(le);
					$('#values #lehex').text(le.toString(16));
				}
				else {
					clearValues();
				}
			});
			
			colorByte($('.name'), -1, definition, false);
		}
		else {
			$('#values #length').empty();
			clearValues();
		}
	});
	
	function clearValues() {
		$('#values #be').empty();
		$('#values #behex').empty();
		$('#values #le').empty();
		$('#values #lehex').empty();
	}
	
	$('body').on('keydown', 'numeric', function(e){-1!==$.inArray(e.keyCode,[46,8,9,27,13,110,190])||/65|67|86|88/.test(e.keyCode)&&(!0===e.ctrlKey||!0===e.metaKey)||35<=e.keyCode&&40>=e.keyCode||(e.shiftKey||48>e.keyCode||57<e.keyCode)&&(96>e.keyCode||105<e.keyCode)&&e.preventDefault()});
	
	function clearSelection() {
	    $('.byte').each(function(index, value){
			$(value).removeClass('selected');
		});
		$('.name').html('&nbsp;');
		$('.fullname').html('&nbsp;');
		$('#filePosition').html('&nbsp;');
	}
	
	$('#hexview').click(function() {
		if (!hover) {
			clearSelection();
		}
		hover = !hover;
	});

	$('document').ready(function() {
		if (readSingleFile($('#fileInput'))) {
			$('#accordion').accordion('option', 'active', 2);
		}
	});

	$('#prev').click(function(e) {
		page -= 1;
		readPage();
	}).attr("disabled", true);

	$('#next').click(function(e) {
		page += 1;
		readPage();
	});

	var prevPage;
	$.each(locations, function(index, value) {
		var page = Math.floor(value / (pageSize / columnCount));
		if (page !== prevPage) {
			$('#pagesOfInterest').append($('<button>').text('Page ' + page).attr('page', page));
			prevPage = page;
		}
	});
	$('button').button();

	$('#pagesOfInterest').on('click', 'button', function() {
		$('#jumpPage').val($(this).attr('page'));
		$('#goPage').trigger('click');
	});

	$('#goPage').click(function() {
		page = parseInt($('#jumpPage').val());
		readPage();
	});

	$('#goOffset').click(function() {
		var offset = parseInt($('#jumpOffset').val());
		page = Math.floor(offset / pageSize);
		readPage();
	});
});

var lastDefinition;
function getDefinition(position) {
	if (lastDefinition && inRange(lastDefinition, position)) {
		// Instead of reading all rows above to check if this is part of a multi-row def,
		// just cache the previous definition and check again.
		// Note that this only works for drawing the highlights, not for a mouseover event.
		return lastDefinition;
	}

	var rowIndex = $.inArray(Math.floor(position / columnCount), locations);
	if (rowIndex !== -1) {
		var row = data[rowIndex];
		for (var i = 0; i < row.length; i++) {
			var definition = row[i];
			if (inRange(definition, position)) {
				lastDefinition = definition;
				return definition;
			}
		}
	}
}

function inRange(definition, position) {
	var offset = definition[0];
	var size = definition[1];
	return position >= offset && position < offset + size;
}

function isStartOrEnd(definition, position) {
	var offset = definition[0];
	var size = definition[1];
	return position === offset || position === offset + size;
}

function hsv2rgb(h, s, v) {
	var r, g, b;
	var i;
	var f, p, q, t;
	s /= 100;
	v /= 100;
	h /= 60;
	i = Math.floor(h);
	f = h - i;
	p = v * (1 - s);
	q = v * (1 - s * f);
	t = v * (1 - s * (1 - f));
	switch(i) {
		case 0: r = v; g = t; b = p; break;
		case 1: r = q; g = v; b = p; break;
		case 2: r = p; g = v; b = t; break;
		case 3: r = p; g = q; b = v; break;
		case 4: r = t; g = p; b = v; break;
		default: r = v; g = p; b = q;
	}
	return 'rgb(' + Math.round(r * 255) + ', ' + Math.round(g * 255) + ', ' + Math.round(b * 255) + ')';
}

var flip = true;
var lastColor = 0;
var colors = {};
function getHue(str) {
	if (!(str in colors)) {
		lastColor = (lastColor + 12) % 180;
		colors[str] = flip ? lastColor : 360 - lastColor;
		flip = !flip;
	}
	return colors[str];
}

var file;
function readSingleFile(fileInput) {
	var files = $(fileInput).prop('files');
	if (!files || files.length != 1){
		return false;
	}
	file = files[0];
	if (!file) {
		return false;
	}
	readPage();
	return true;
}

function toHex(value) {
	var hex = value.toString(16);
	hex = (hex.length === 1) ? '0' + hex : hex;
	return hex;
}

function getData(offset, size, callback) {
	var reader = new FileReader();
	reader.onload = function(e) {
		var buffer = new Uint8Array(e.target.result);
		callback(buffer);
	};
	var slice = file.slice(offset, offset + size);
	reader.readAsArrayBuffer(slice);
}

function readPage() {
	var pageOffset = page * pageSize;
	if (page > 0) {
		$('#prev').removeAttr('disabled');
	}
	else {
		$('#prev').attr('disabled', true);
	}
	$('#jumpPage').val(page);
	$('#jumpOffset').val(pageOffset);

	getData(pageOffset, pageSize, function(buffer) {
		var pagePosition = 0;
		$('#hexview').empty();
		$('#asciiview').empty();

		for (var row = 0; pagePosition < buffer.length; row++) {
			if (buffer.length - pagePosition < columnCount) {
				columnCount = buffer.length - pagePosition;
			}

			var hexNr = (pagePosition + pageOffset).toString(16);
			var hexRow = $('<div>').addClass('row')
				.append($('<div>').addClass('linenr').text(hexNr));

			$('#hexview').append(hexRow).append($('<div>').addClass('spacerRow row'));

			var asciiRow = $('<div>').addClass('row');
			$('#asciiview').append(asciiRow).append($('<div>').addClass('spacerRow row'));

			for (var column = 0; column < columnCount; column++, pagePosition++) {
				var filePosition = pageOffset + pagePosition;
				var definition = getDefinition(filePosition);

				var byte = buffer[pagePosition] & 0xff;
				var hex = toHex(byte);

				if (column % 2 == 0) {
					var spacer = $('<span>').addClass('spacer').html('&nbsp;');
					if (definition) {
						if (!isStartOrEnd(definition, filePosition)) {
							colorByte(spacer, filePosition, definition, true);
						}
					}
					hexRow.append(spacer);
				}
				var hexByte = $('<span>').addClass('byte').attr('position', filePosition).text(hex);
				var hexByteWrapper = $('<span>').addClass('byteWrapper').append(hexByte);
				hexRow.append(hexByteWrapper);

				var character = byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '\u00B7';
				var asciiByte = $('<span>').addClass('byte').attr('position', filePosition).text(character);
				var asciiByteWrapper = $('<span>').addClass('byteWrapper').append(asciiByte);
				asciiRow.append(asciiByteWrapper);

				if (definition) {
					colorByte(hexByteWrapper, filePosition, definition, false);
					colorByte(asciiByteWrapper, filePosition, definition, false);
				}
			}
		}
	});
}

function colorByte(wrapper, filePosition, definition, isSpacer) {
	var backgroundRgb = hsv2rgb(getHue(definition[2]) % 360, 50, 80);
	var borderRgb = hsv2rgb(getHue(definition[2]) % 360, 100, 100);

	wrapper.css('background-color', backgroundRgb);
	wrapper.css('color', 'black');

	var offset = definition[0];
	var size = definition[1];
	var border = '1px solid ' + borderRgb;
	wrapper.css('border-top', border);
	wrapper.css('border-bottom', border);

	if (!isSpacer) {
		// spacer should never start or end the highlight,
		// but does as a spacer does share the fileposition with its nearest byte
		if (filePosition === offset) {
			wrapper.css('border-left', border);
		}
		if (filePosition === offset + size -1) {
			wrapper.css('border-right', border);
		}
	}
}

</script>
<body>
	<div class="page-container">
		<div class="split-pane fixed-right">
			<div class="split-pane-component" id="left-component">
				<div class="hexviewWrapper">
					<div id="hexview"></div>
					<div id="asciiview"></div>
				</div>
			</div>
			<div class="split-pane-divider" id="my-divider"></div>
			<div class="split-pane-component" id="right-component">
				<div id="accordion">
					<h3>Data source</h3>
					<div>
						<p>
							<input type="file" id="fileInput" onChange="readSingleFile(this)"/>
						</p>
					</div>
					<h3>Data offset</h3>
					<div>
						<p>
							<input type="text" size="4" id="jumpPage" class="numeric" value="0"><button id="goPage">Jump to page</button>
							<input type="text" size="8" id="jumpOffset" class="numeric" value="0"><button id="goOffset">Jump to offset</button>
							<button id="prev">Previous page</button>
							<button id="next">Next page</button><br>
						</p>
					</div>
					<h3>Values <span class="name"></span></h3>
					<div>
						<div id="values">
							<fieldset>
								<legend>Selection</legend>
								Size: <span id="length"></span> bytes
							</fieldset>
							<fieldset>
								<legend>Offset</legend>
								dec: <span id="filePosition"></span><br>
								hex: <span id="filePositionhex"></span>
							</fieldset>
							<fieldset>
								<legend>Big Endian</legend>
								dec: <span id="be"></span><br>
								hex: <span id="behex"></span>
							</fieldset>
							<fieldset>
								<legend>Little Endian</legend>
								dec: <span id="le"></span><br>
								hex: <span id="lehex"></span>
							</fieldset>
							<fieldset>
								<legend>Path</legend>
								<span class="fullname">&nbsp;</span>
							</fieldset>
						</div>
					</div>
					<h3>Pages of interest</h3>
					<div id="pagesOfInterest">Pages of interest:<br></div>
				</div>
			</div>
		</div>
	</div>
	<script>
		var locations = []<!-- generated -->;
		var data = []<!-- generated -->;
	</script>
</body>
</html>